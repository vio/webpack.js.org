"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9317],{9317:function(e,a,t){t.r(a),t(7378);var n=t(2682);function r(){return(r=Object.assign||function(e){for(var a=1;a<arguments.length;a++){var t=arguments[a];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}function i({components:e,...a}){return(0,n.kt)("wrapper",r({components:e},a),(0,n.kt)("p",null,"A variety of interfaces are available to customize the compilation process.\nSome features overlap between interfaces, e.g. a configuration option may be\navailable via a CLI flag, while others exist only through a single interface.\nThe following high-level information should get you started."),(0,n.kt)("h2",{id:"cli"},"CLI",(0,n.kt)("a",{href:"#cli","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,"The Command Line Interface (CLI) to configure and interact with your build. It\nis especially useful in the case of early prototyping and profiling. For the\nmost part, the CLI is used to kick off the process using a configuration\nfile and a few flags (e.g. ",(0,n.kt)("inlineCode",{parentName:"p"},"--env"),")."),(0,n.kt)("p",null,(0,n.kt)("a",{href:"/api/cli",parentName:"p"},"Learn more about the CLI!")),(0,n.kt)("h2",{id:"module"},"Module",(0,n.kt)("a",{href:"#module","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,"When processing modules with webpack, it is important to understand the\ndifferent module syntaxes – specifically the ",(0,n.kt)("a",{href:"/api/module-methods",parentName:"p"},"methods"),"\nand ",(0,n.kt)("a",{href:"/api/module-variables",parentName:"p"},"variables")," – that are supported."),(0,n.kt)("p",null,(0,n.kt)("a",{href:"/api/module-methods",parentName:"p"},"Learn more about modules!")),(0,n.kt)("h2",{id:"node"},"Node",(0,n.kt)("a",{href:"#node","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,"While most users can get away with using the CLI along with a\nconfiguration file, more fine-grained control of the compilation can be\nachieved via the Node interface. This includes passing multiple configurations,\nprogrammatically running or watching, and collecting stats."),(0,n.kt)("p",null,(0,n.kt)("a",{href:"/api/node",parentName:"p"},"Learn more about the Node API!")),(0,n.kt)("h2",{id:"loaders"},"Loaders",(0,n.kt)("a",{href:"#loaders","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,"Loaders are transformations that are applied to the source code of a module.\nThey are written as functions that accept source code as a parameter and return\na new version of that code with transformations applied."),(0,n.kt)("p",null,(0,n.kt)("a",{href:"/api/loaders",parentName:"p"},"Learn more about loaders!")),(0,n.kt)("h2",{id:"plugins"},"Plugins",(0,n.kt)("a",{href:"#plugins","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,n.kt)("span",{className:"header-link",parentName:"a"}))),(0,n.kt)("p",null,"The plugin interface allows users to tap directly into the compilation process.\nPlugins can register handlers on lifecycle hooks that run at different points\nthroughout a compilation. When each hook is executed, the plugin will have full\naccess to the current state of the compilation."),(0,n.kt)("p",null,(0,n.kt)("a",{href:"/api/plugins",parentName:"p"},"Learn more about plugins!")))}i.isMDXComponent=!0,a.default=i}}]);